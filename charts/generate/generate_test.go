package main

import (
	"path/filepath"
	"reflect"
	"testing"
)

func TestBuildFileList(t *testing.T) {
	tests := []struct {
		name         string
		templatePath string
		want         []string
		wantErr      bool
	}{
		{
			"valid",
			filepath.Join("..", "templates"),
			[]string{
				"../templates/base.tmpl",
				"../templates/basic.tmpl",
				"../templates/lightweight-charts.standalone.production.js",
				"../templates/timeseries-markers.tmpl",
				"../templates/timeseries.tmpl",
			},
			false,
		},
	}
	for x := range tests {
		tt := tests[x]
		t.Run(tt.name, func(t *testing.T) {
			templatePath = tt.templatePath
			got, err := buildFileList()
			if (err != nil) != tt.wantErr {
				t.Errorf("buildFileList() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("buildFileList() got = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestByteJoin(t *testing.T) {
	type args struct {
		b []byte
	}
	tests := []struct {
		name string
		args args
		want string
	}{
		{
			"valid",
			args{
				[]byte("Hello"),
			},
			"{72,101,108,108,111}",
		},
	}
	for x := range tests {
		tt := tests[x]
		t.Run(tt.name, func(t *testing.T) {
			if got := byteJoin(tt.args.b); got != tt.want {
				t.Errorf("byteJoin() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestGenerateMap(t *testing.T) {
	tests := []struct {
		name         string
		templatePath string
		want         []templateData
		wantErr      bool
	}{
		{
			"valid",
			filepath.Join("testdata"),
			[]templateData{
				{
					"base.tmpl",
					"{40,226,149,175,194,176,226,150,161,194,176,239,188,137,226,149,175,239,184,181,32,226,148,187,226,148,129,226,148,187,10}",
				},
			},
			false,
		},
	}
	for x := range tests {
		tt := tests[x]
		t.Run(tt.name, func(t *testing.T) {
			templatePath = tt.templatePath
			got, err := generateMap()
			if (err != nil) != tt.wantErr {
				t.Errorf("generateMap() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("generateMap() got = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestReadTemplateToByte(t *testing.T) {
	type args struct {
		input string
	}
	tests := []struct {
		name    string
		args    args
		want    []byte
		wantErr bool
	}{
		{
			"valid",
			args{
				filepath.Join("..", "templates", "base.tmpl"),
			},
			[]byte{123, 123, 100, 101, 102, 105, 110, 101, 32, 34, 98, 97, 115, 101, 34, 125, 125, 10, 60, 33, 68, 79, 67, 84, 89, 80, 69, 32, 72, 84, 77, 76, 62, 10, 60, 104, 116, 109, 108, 32, 108, 97, 110, 103, 61, 39, 101, 110, 39, 62, 10, 32, 32, 32, 32, 60, 104, 101, 97, 100, 62, 10, 32, 32, 32, 32, 32, 32, 32, 32, 60, 109, 101, 116, 97, 32, 99, 104, 97, 114, 115, 101, 116, 61, 39, 117, 116, 102, 45, 56, 39, 62, 10, 32, 32, 32, 32, 32, 32, 32, 32, 60, 116, 105, 116, 108, 101, 62, 123, 123, 116, 101, 109, 112, 108, 97, 116, 101, 32, 34, 116, 105, 116, 108, 101, 34, 32, 46, 125, 125, 32, 45, 32, 67, 104, 97, 114, 116, 115, 60, 47, 116, 105, 116, 108, 101, 62, 10, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 60, 115, 99, 114, 105, 112, 116, 32, 115, 114, 99, 61, 34, 104, 116, 116, 112, 115, 58, 47, 47, 117, 110, 112, 107, 103, 46, 99, 111, 109, 47, 108, 105, 103, 104, 116, 119, 101, 105, 103, 104, 116, 45, 99, 104, 97, 114, 116, 115, 64, 51, 46, 49, 46, 53, 47, 100, 105, 115, 116, 47, 108, 105, 103, 104, 116, 119, 101, 105, 103, 104, 116, 45, 99, 104, 97, 114, 116, 115, 46, 115, 116, 97, 110, 100, 97, 108, 111, 110, 101, 46, 112, 114, 111, 100, 117, 99, 116, 105, 111, 110, 46, 106, 115, 34, 62, 60, 47, 115, 99, 114, 105, 112, 116, 62, 10, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 60, 108, 105, 110, 107, 32, 114, 101, 108, 61, 34, 115, 116, 121, 108, 101, 115, 104, 101, 101, 116, 34, 32, 104, 114, 101, 102, 61, 34, 104, 116, 116, 112, 115, 58, 47, 47, 115, 116, 97, 99, 107, 112, 97, 116, 104, 46, 98, 111, 111, 116, 115, 116, 114, 97, 112, 99, 100, 110, 46, 99, 111, 109, 47, 98, 111, 111, 116, 115, 116, 114, 97, 112, 47, 53, 46, 48, 46, 48, 45, 97, 108, 112, 104, 97, 49, 47, 99, 115, 115, 47, 98, 111, 111, 116, 115, 116, 114, 97, 112, 46, 109, 105, 110, 46, 99, 115, 115, 34, 32, 105, 110, 116, 101, 103, 114, 105, 116, 121, 61, 34, 115, 104, 97, 51, 56, 52, 45, 114, 52, 78, 121, 80, 52, 54, 75, 114, 106, 68, 108, 101, 97, 119, 66, 103, 68, 53, 116, 112, 56, 89, 55, 85, 122, 109, 76, 65, 48, 53, 111, 77, 49, 105, 65, 69, 81, 49, 55, 67, 83, 117, 68, 113, 110, 85, 75, 50, 43, 107, 57, 108, 117, 88, 81, 79, 102, 88, 74, 67, 74, 52, 73, 34, 32, 99, 114, 111, 115, 115, 111, 114, 105, 103, 105, 110, 61, 34, 97, 110, 111, 110, 121, 109, 111, 117, 115, 34, 62, 10, 32, 32, 32, 32, 60, 47, 104, 101, 97, 100, 62, 10, 32, 32, 32, 32, 60, 98, 111, 100, 121, 62, 10, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 123, 123, 116, 101, 109, 112, 108, 97, 116, 101, 32, 34, 99, 111, 110, 116, 101, 110, 116, 34, 32, 46, 125, 125, 10, 32, 32, 32, 32, 32, 32, 32, 32, 60, 115, 99, 114, 105, 112, 116, 32, 115, 114, 99, 61, 34, 104, 116, 116, 112, 115, 58, 47, 47, 99, 100, 110, 46, 106, 115, 100, 101, 108, 105, 118, 114, 46, 110, 101, 116, 47, 110, 112, 109, 47, 112, 111, 112, 112, 101, 114, 46, 106, 115, 64, 49, 46, 49, 54, 46, 48, 47, 100, 105, 115, 116, 47, 117, 109, 100, 47, 112, 111, 112, 112, 101, 114, 46, 109, 105, 110, 46, 106, 115, 34, 32, 105, 110, 116, 101, 103, 114, 105, 116, 121, 61, 34, 115, 104, 97, 51, 56, 52, 45, 81, 54, 69, 57, 82, 72, 118, 98, 73, 121, 90, 70, 74, 111, 102, 116, 43, 50, 109, 74, 98, 72, 97, 69, 87, 108, 100, 108, 118, 73, 57, 73, 79, 89, 121, 53, 110, 51, 122, 86, 57, 122, 122, 84, 116, 109, 73, 51, 85, 107, 115, 100, 81, 82, 86, 118, 111, 120, 77, 102, 111, 111, 65, 111, 34, 32, 99, 114, 111, 115, 115, 111, 114, 105, 103, 105, 110, 61, 34, 97, 110, 111, 110, 121, 109, 111, 117, 115, 34, 62, 60, 47, 115, 99, 114, 105, 112, 116, 62, 10, 32, 32, 32, 32, 32, 32, 32, 32, 60, 115, 99, 114, 105, 112, 116, 32, 115, 114, 99, 61, 34, 104, 116, 116, 112, 115, 58, 47, 47, 115, 116, 97, 99, 107, 112, 97, 116, 104, 46, 98, 111, 111, 116, 115, 116, 114, 97, 112, 99, 100, 110, 46, 99, 111, 109, 47, 98, 111, 111, 116, 115, 116, 114, 97, 112, 47, 53, 46, 48, 46, 48, 45, 97, 108, 112, 104, 97, 49, 47, 106, 115, 47, 98, 111, 111, 116, 115, 116, 114, 97, 112, 46, 109, 105, 110, 46, 106, 115, 34, 32, 105, 110, 116, 101, 103, 114, 105, 116, 121, 61, 34, 115, 104, 97, 51, 56, 52, 45, 111, 101, 115, 105, 54, 50, 104, 79, 76, 102, 122, 114, 121, 115, 52, 76, 120, 82, 70, 54, 51, 79, 74, 67, 88, 100, 88, 68, 105, 112, 105, 89, 87, 66, 110, 118, 84, 108, 57, 89, 57, 47, 84, 82, 108, 119, 53, 120, 108, 75, 73, 69, 72, 112, 78, 121, 118, 118, 68, 83, 104, 103, 102, 47, 34, 32, 99, 114, 111, 115, 115, 111, 114, 105, 103, 105, 110, 61, 34, 97, 110, 111, 110, 121, 109, 111, 117, 115, 34, 62, 60, 47, 115, 99, 114, 105, 112, 116, 62, 10, 32, 32, 32, 32, 60, 47, 98, 111, 100, 121, 62, 10, 60, 47, 104, 116, 109, 108, 62, 10, 123, 123, 101, 110, 100, 125, 125},
			false,
		},
	}
	for x := range tests {
		tt := tests[x]
		t.Run(tt.name, func(t *testing.T) {
			got, err := readTemplateToByte(tt.args.input)
			if (err != nil) != tt.wantErr {
				t.Errorf("readTemplateToByte() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("readTemplateToByte() got = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestStripPath(t *testing.T) {
	type args struct {
		in string
	}
	tests := []struct {
		name string
		args args
		want string
	}{
		{
			"valid",
			args{
				"valid/path",
			},
			"path",
		},
	}
	for x := range tests {
		tt := tests[x]
		templatePath = tt.name
		t.Run(tt.name, func(t *testing.T) {
			if got := stripPath(tt.args.in); got != tt.want {
				t.Errorf("stripPath() = %v, want %v", got, tt.want)
			}
		})
	}
}
